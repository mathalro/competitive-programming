#include <bits/stdc++.h>

using namespace std;

struct aresta {
	vector<int> v;
	int peso;
	aresta() {}
	aresta(vector<int> a, int b) : v(a), peso(b) {}

	bool operator < (const aresta &p) const {
		return p.peso < peso;
	}
};

queue<aresta> filaModelo;
vector<int> inicial, final;

map< vector<int>, vector<aresta> > grafo;
map< vector<int>, vector<aresta> >::iterator it;

map<vector<int>, int > distancia;
map<vector<int>, int >::iterator itD;

int djkstra(vector<int> origem, vector<int> destino) {
	priority_queue<aresta> q;
	q.push(aresta(origem, 0));
	distancia.insert(make_pair(origem, 0));

	while (!q.empty()) {
		aresta u = q.top(); q.pop();				//tira um no da pilha

		if (u.v == destino) {
			itD = distancia.find(u.v);
			return itD->second;	
		}

		it = grafo.find(u.v);					//encontra esse ertice no grafo
		itD = distancia.find(u.v);				//encontra esse vertice no map de distancias
		int distanciaAual = itD->second;		

		for (int i = 0; i < it->second.size(); i++) {
			int peso = it->second[i].peso;		//salva o peso para esse adjacente
			vector<int> v = it->second[i].v;	//salva o indice do vertice atual
			itD = distancia.find(v);			//encontra esse vertice no vertice atual
			if (itD == distancia.end()) {		
				distancia.insert(make_pair(v, peso + distanciaAual));
				q.push(aresta(v, peso + distanciaAual));
				continue;
			}
			if (itD->second > peso + distanciaAual) {
				distancia.insert(make_pair(v, peso + distanciaAual));
				q.push(aresta(v, peso + distanciaAual));
			}
		}
	}
}

int djkstra2(vector<int> origem, vector<int> destino) {
	priority_queue<aresta> q;
	q.push(aresta(origem, 0));
	distancia.insert(make_pair(origem, 0));

	while (!q.empty()) {
		aresta u = q.top(); q.pop();				//tira um no da pilha

		if (u.v == destino) {
			itD = distancia.find(u.v);
			return itD->second;	
		}

		itD = distancia.find(u.v);				//encontra esse vertice no map de distancias
		int distanciaAual = itD->second;		

		vector<aresta> adjacentes;
		const int dados1[] = {0, 0, 1, 1, 2, 2, 3, 4, 5, 6};
		const int dados2[] = {1, 4, 2, 5, 3, 6, 7, 5, 6, 7};
		for (int i = 0; i < 10; i++) {
			if (u.v[dados1[i]] != u.v[dados2[i]]) {
				aresta aux = inserir(u.v, dados1[i], dados2[i]);
				adjacentes.push_back(aux);
			}
		}

		for (int i = 0; i < adjacentes.size(); i++) {
			int peso = adjacentes[i].peso;		//salva o peso para esse adjacente
			vector<int> v = adjacentes[i].v;	//salva o indice do vertice atual
			itD = distancia.find(v);			//encontra esse vertice no vertice atual
			if (itD == distancia.end()) {		
				distancia.insert(make_pair(v, peso + distanciaAual));
				q.push(aresta(v, peso + distanciaAual));
				continue;
			}
			if (itD->second > peso + distanciaAual) {
				distancia.insert(make_pair(v, peso + distanciaAual));
				q.push(aresta(v, peso + distanciaAual));
			}
		}
	}
}


aresta inserir(vector<int> adjacente, int elem1, int elem2) {
	int peso;
	vector<int> atual = adjacente;
	peso = adjacente[elem1] + adjacente[elem2];
	swap(adjacente[elem1], adjacente[elem2]);
	aresta criado = aresta(adjacente, peso);
	if(grafo.find(criado.v) == grafo.end())
		filaModelo.push(criado);
	return criado;
}

void criaAdjacentes(vector<int> atual) {
	vector<aresta> adjacentes;
	const int dados1[] = {0, 0, 1, 1, 2, 2, 3, 4, 5, 6};
	const int dados2[] = {1, 4, 2, 5, 3, 6, 7, 5, 6, 7};
	for (int i = 0; i < 10; i++) {
		if (atual[dados1[i]] != atual[dados2[i]]) {
			aresta aux = inserir(atual, dados1[i], dados2[i]);
			adjacentes.push_back(aux);
		}
	}

	grafo.insert(make_pair(atual, adjacentes));
}

int main () {
	int x;
	for(int i = 0; i < 8; i++) {
		scanf("%d", &x);
		inicial.push_back(x);
	}

	for (int i = 0; i < 8; i++) {
		scanf("%d", &x);
		final.push_back(x);
	}

	if (inicial == final) {
		printf("\n");
		return 0;
	}

	/**filaModelo.push(aresta(inicial, 0));

	while(!filaModelo.empty()) {
		if (grafo.find(filaModelo.front().v) == grafo.end())
			criaAdjacentes(filaModelo.front().v);
		filaModelo.pop();
	}**/

	printf("%d\n", djkstra2(inicial, final));

	return 0;
}
